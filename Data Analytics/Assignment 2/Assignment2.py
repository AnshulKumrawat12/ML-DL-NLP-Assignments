# -*- coding: utf-8 -*-
"""DA_Assignment2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1017s-HqEl6T4bHsepjEg17ryoghwXubu

# **Import Libraries**
"""

import numpy as np
import pandas as pd

"""# **Dataset Loading**"""

dataset = pd.read_csv("/content/drive/MyDrive/Data Analytics /Assignment 2/04_cricket_1999to2011.csv", usecols= ["Match", "Innings", "Over", "Runs", "Runs.Remaining", "Wickets.in.Hand", "Innings.Total.Runs","Error.In.Data"])

print(dataset.shape)
dataset.head()

data = dataset[(dataset["Innings"]==1) & (dataset["Error.In.Data"]==0) & (dataset["Wickets.in.Hand"] !=0)]
# data = dataset[(dataset.Innings==1) & (dataset["Error.In.Data"]==0)]

print(data.shape)
data.head()

#Overs Remaining
data["Overs.Remaining"] = 50 - data["Over"]

data.head()

"""# **Question 1**

## **Function Definition**

1.   Z(u,w) : Z(u,w) = Z0(w)[1 - exp{-b(w)u}]
2.   Initial_Z0()
3.   sum_squared_error()
4.   DuckworthLewis20Params()
"""

def Z_u_w(Z0_w, b_w, u):
  return Z0_w*(1 - np.exp(-b_w * u))

def Initial_Z0():
  initial_Z0 = []
  for i in range(10):
    temp = data[(data["Wickets.in.Hand"] == i+1)]
    temp1 = temp.groupby(["Match"])
    temp1 = temp1["Runs.Remaining"].mean()
    temp1 = np.mean(temp1)
    initial_Z0.append(temp1)
  
  return initial_Z0

Z0 = Initial_Z0()
for i in range(10):
  Z0.append(0.04)
Z0_b = Z0

print(Z0_b)

from tqdm import tqdm
def sum_squared_error(Z0):
  sq_error = []
  for i in tqdm(range(len(data))):
    w = data["Wickets.in.Hand"].values[i] - 1
    runs = data["Runs.Remaining"].values[i]
    pred_target = Z_u_w(Z0[w], Z0[10 + w], data["Overs.Remaining"].values[i])
    squared_error = (pred_target - runs)**2
    sq_error.append(squared_error)
  return np.sum(sq_error)

from scipy.optimize import minimize

def DuckworthLewis20Params():
  Final_Z0_b = minimize(sum_squared_error, Z0_b, method = "Powell")
  Final_Z0 = Final_Z0_b.x[:10]
  Final_b = Final_Z0_b.x[10:]
  Error1 = Final_Z0_b.fun
  Error_per_point = Error1/len(data)
  print("Z0: ", Final_Z0)
  print("b: ", Final_b)
  print("Error: ", Error1)
  print("Error-per-point: ", Error_per_point)
  
  return Final_Z0, Final_b

Final_Z0, Final_b = DuckworthLewis20Params()


Floor_Z0 = np.floor(Final_Z0).astype(float)
print(Floor_Z0)

"""# **Graph Plot**"""

import matplotlib.pyplot as plt

over_remained  = np.array([i for i in range(51)])
print(type(over_remained))
Z0_plot = Z_u_w(Floor_Z0[9], Final_b[9], 50)

x = [0,50]
y = [0,100]

plt.plot(x,y, color = 'black')

for i in range(10):
  Y = Z_u_w(Floor_Z0[i], Final_b[i], (over_remained))/Z0_plot
  plt.plot( over_remained, Y*100, label = " Wickets Remained : {}, Z({}) = {}".format(i+1, i+1, Floor_Z0[i]))

plt.legend(loc = 'upper right', bbox_to_anchor=(1.8, 1))
plt.xlabel("Over Remaining")
plt.ylabel("% of Resources Remaining ")
plt.show()

"""# **Question 2**

# **Function Definition**

1.   Z_u_w_L() : Z(u,w) = Z0(w)[1 - exp{-Lu/Z0(w)}]
2.   sum_squared_error2()
3.   DuckworthLewis11Params()
"""

def Z_u_w_L(Z0_w,L,u):
  return Z0_w*(1 - np.exp( - (L*u)/Z0_w))

L = 3
Z0_L = Initial_Z0()
Z0_L.append(L)
print(Z0_L)

def sum_squared_error2(Z0):
  sq_error = []
  for i in tqdm(range(len(data))):
    w = data["Wickets.in.Hand"].values[i] - 1
    runs = data["Runs.Remaining"].values[i]
    pred_target = Z_u_w_L(Z0[w], Z0[10], data["Overs.Remaining"].values[i])
    squared_error = (pred_target - runs)**2
    sq_error.append(squared_error)
  return np.sum(sq_error)

def DuckworthLewis11Params():
  Final_Z0_L = minimize(sum_squared_error2, Z0_L, method = "L-BFGS-B")
  Final_Z0_2 = Final_Z0_L.x[:10]
  Final_L = Final_Z0_L.x[10]
  Error2 = Final_Z0_L.fun
  Error_per_point_2 = Error2/len(data)

  print("Z0: ", Final_Z0_2)
  print("L: ", Final_L)
  print("Error: ", Error2)
  print("Error-per-point: ", Error_per_point_2)
  return Final_Z0_2, Final_L

Final_Z0_2, Final_L = DuckworthLewis11Params()

Floor_Z0_2 = np.floor(Final_Z0_2).astype(float)
print(Floor_Z0_2)

"""# **Graph Plot**"""

over_remained  = np.array([i for i in range(51)])
print(type(over_remained))
Z0_L_plot = Z_u_w_L(Floor_Z0_2[9], Final_L, 50)

x = [0,50]
y = [0,100]

plt.plot(x,y, color = 'black')
for i in range(10):
  Y = Z_u_w_L(Floor_Z0_2[i], Final_L, (over_remained))/Z0_L_plot
  plt.plot( over_remained, Y*100, label = " Wickets Remained : {}, Z({}) = {}".format(i+1, i+1, Floor_Z0_2[i]))

plt.legend(loc = 'upper right', bbox_to_anchor=(1.8, 1))
plt.xlabel("Over Remaining")
plt.ylabel("% of Resources Remaining ")
plt.show()

